参考：[背包九讲2.0](https://github.com/tianyicui/pack/blob/master/V2.pdf)

**$01$背包：**

一般解法和空间优化比较熟悉，略过，这里仅记一下初始化时的一个小问题.

对于要求恰好装满背包时，我们可以在初始化时令$F[0] = 0$，$F[1...V]$均为$-\infty$，其中$V$是背包容量，$F$是状态数组.

而在没有要求恰好装满背包时，则可以全部初始化为$0$.

可以这样理解其中的区别：初始化的$F$数组是没有任何物品放入背包时的解，在要求恰好装满的情况下，除了$0$以外的其他容量均没有合法的解，而如果不要求装满，那么没有装入任何物品时，所有容量的背包都有一个合法的零解.


**完全背包问题：**

给出$N$种物品，每种物品有无限个，给出每种物品的体积$C_i$和价值$W_i$，给出背包的容量$V$，求不超过背包容量的情况下不断装入物品，可以得到的最大价值。

思路：

首先我们考虑最基本的转移方程：

令$F[i][j]$表示考虑前$i$件物品，背包容量为$j$时的最大价值，有：

$$
F[i][j] = max\{F[i - 1][j - kC_i] + kW_i | 0 \leq kC_i \leq j\}
$$

我们用更清晰的形式写出来：

$$
F[i][j] = max\{F[i - 1][j],F[i - 1][j - C_i] + W_i,F[i - 1][j - 2C_i] + 2W_i,...,F[i - 1][j - kC_i] + kW_i\}
$$
$$

F[i][j - C_i] = max\{\qquad F[i - 1][j - C_i],F[i - 1][j - 2C_i] + W_i,...,F[i - 1][j - kC_i] + (k - 1)W_i\}
$$
把两个式子综合一下，得到：

$$
F[i][j] = max\{F[i - 1][j],F[i][j - C_i] + W_i\}
$$
消去第一维，得到：

$$
F[j] = max\{F[j],F[j - C_i] + W_i\}
$$
从代码上来看，只需调转$01$背包中第二层循环的枚举顺序：

```cpp
for(int i = 1; i <= N; i ++ )
{
    for(int j = C[i]; j <= V; j ++ )
    {
        F[j] = max(F[j],F[j - C[i]] + W[i]); 

    }
}
```
我们也可以从另一个角度来理解这个方程：当我们考虑$F[i][j]$时，需要的是已经选入第$i$件物品的子结果$F[i - 1][j - C_i$，因此在一维的情况下，正序枚举容量时，$F[j - C_i]$已经是一个考虑过选入$C_i$的子结果，因此转移方程成立。

[例题](https://www.acwing.com/problem/content/3/)

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define debug(x) cout << #x << " = " << x << endl;
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define pll pair<ll,ll>
#define ld long double
#define ull unsigned long long
#define pb push_back
#define INF 0x3f3f3f3f3f3f3f3f
#define endl '\n'
const ll N = 1000 + 5;
const ll M = 1e4 + 5;
ll n,V;
ll v[N],w[N];
ll f[N];
int main()
{
	cin >> n >> V;
	for(ll i = 1; i <= n; i ++ )
	{
		cin >> v[i] >> w[i];
	}
	for(ll i = 1; i <= n; i ++ )
	{
		for(ll j = v[i]; j <= V; j ++ )
		{
			f[j] = max(f[j],f[j - v[i]] + w[i]);
		}
	}
	cout << f[V] << endl;
}
```



